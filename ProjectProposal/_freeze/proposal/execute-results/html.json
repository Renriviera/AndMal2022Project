{
  "hash": "b589b32558981d65aad46fcc0fa61ece",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"EDAV Proposal\"\nformat: html\n---\n\n### Project Proposal:\n\nEDAV project on android malware/benign code\n\nI am interested in this area because I think cybersecurity does not get enough mainstream recognition- it is critical to the well-being of every other sector, it is also a data-rich(data quality is high too) computer centric field. Recently global events like the crowdstrike fiasco piqued my interest. I have always wanted to try doing some work in cybersecurity and this will be the first time! \n### Questions:\nHow imbalanced are the various categories and families of malware. What sort of permissions and API calls are most distinctive for each? What about memory/battery usage or network profiles?  Zero-days are never-seen before malware that exploit vulnerabilities previously unknown. There is also code that could not compile in the lab environment with reasons listed why. Should these be just considered as outliers or is there valuable knowledge to be gained from contrastive EDAV? \n\n### Datasets I plan to use(I will use the first link listed but listed other relevant ones as well):\nhttps://www.unb.ca/cic/datasets/maldroid-2020.html\nCollected by UNB's Canadian Institute for Cybersecurity from various(cited in the link) reputable sources.\n— have access already, 17341 samples until 2018, 5 categories: Adware, Banking malware, SMS malware, Riskware, and Benign, APK files: 17,341 Android samples spanning between five distinct categories: Adware, Banking malware, SMS malware, Riskware, and Benign.\nCapturing-logs: The output analysis results of 13,077 samples in five categories: Adware, Banking malware, SMS malware, Riskware, and Benign.\nCSV files:\n470 extracted features for 11,598 APK files comprising frequencies of system calls, binders, and composite behaviors\n139 extracted features for 11,598 APK files comprising frequencies of system calls\n50,621 extracted features for 11,598 APK files comprising static information, such as intent actions, permissions, intent consts, permissions, files, method tags, sensitive APIs, services, packages, receivers, etc.\n\n### Other interesting sources:\n\nhttps://www.unb.ca/cic/datasets/andmal2020.html \n— have access already,  big dataset 400k samples\nhttps://androzoo.uni.lu/?utm_source=chatgpt.com\n— don’t have access yes, very big dataset 20M+ samples\nhttps://data.mendeley.com/datasets/rvjptkrc34/1\n— have access already, small 1500 samples\n\n### Load Libraries and Preprocessed Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ lubridate 1.9.4     ✔ tibble    3.3.0\n✔ purrr     1.2.0     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(viridis)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: viridisLite\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(scales)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:viridis':\n\n    viridis_pal\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tibble)\nlibrary(tidyr)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load preprocessed data from preprocessing.qmd\nandmal_after <- readRDS(\"data/processed/andmal_after.rds\")\nandmal_before <- readRDS(\"data/processed/andmal_before.rds\")\nfeature_definitions <- readRDS(\"data/processed/feature_definitions.rds\")\n\n# Extract feature definitions for use in visualizations\nui_features <- feature_definitions$ui_features\ndex_apis <- feature_definitions$dex_apis\nwebview_cols <- feature_definitions$webview_cols\nfileio_apis <- feature_definitions$fileio_apis\ndb_apis <- feature_definitions$db_apis\ndb_read_apis <- feature_definitions$db_read_apis\ndb_write_apis <- feature_definitions$db_write_apis\nfiledb_apis <- feature_definitions$filedb_apis\n\n# Global color scheme\nandmal_theme <- theme_minimal(base_family = \"sans\") +\n  theme(\n    plot.title    = element_text(face = \"bold\", hjust = 0),\n    plot.subtitle = element_text(hjust = 0),\n    axis.text.x   = element_text(angle = 45, hjust = 1),\n    legend.position = \"bottom\"\n  )\n\ncategory_col  <- scale_colour_viridis_d(option = \"H\", end = 0.9)\ncategory_fill <- scale_fill_viridis_d(option = \"H\", end = 0.9)\n\ncat(sprintf(\"Loaded andmal_after: %d rows, %d columns\\n\", nrow(andmal_after), ncol(andmal_after)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLoaded andmal_after: 25059 rows, 185 columns\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(sprintf(\"Loaded andmal_before: %d rows, %d columns\\n\", nrow(andmal_before), ncol(andmal_before)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLoaded andmal_before: 28380 rows, 188 columns\n```\n\n\n:::\n:::\n\n\n## Visualizations\n\n\n::: {.cell}\n\n:::\n\n\n### Memory Analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ensure required libraries are loaded (defensive in case cached session missed load step)\nlibrary(ggplot2)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(scales)\nlibrary(viridis)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: viridisLite\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'viridis'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:scales':\n\n    viridis_pal\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)\nlibrary(tibble)\n\n# Boxplots memory footprint by category\np_mem <- ggplot(get_combined_data(), aes(x = Category, y = log_PssTotal, fill = Category)) +\n  geom_boxplot(outlier.alpha = 0.3) +\n  facet_wrap(~ reboot_state) +\n  labs(\n    title    = \"Memory footprint by malware category\",\n    subtitle = \"Memory_PssTotal on log10 scale, split by before/after reboot\",\n    x = \"Malware category\",\n    y = \"log10(Memory_PssTotal + 1)\"\n  ) +\n  category_fill +\n  andmal_theme\n\np_mem\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-1.png){width=960}\n:::\n\n```{.r .cell-code}\n# Process intensity by category\n\np_proc <- ggplot(get_combined_data(), aes(x = Category, y = log_Process_total, fill = Category)) +\n  geom_boxplot(outlier.alpha = 0.3) +\n  facet_wrap(~ reboot_state) +\n  labs(\n    title    = \"Process intensity by malware category\",\n    subtitle = \"Total number of processes (Process_total) on log10 scale\",\n    x = \"Malware category\",\n    y = \"log10(Process_total + 1)\"\n  ) +\n  category_fill +\n  andmal_theme\n\np_proc\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-2.png){width=960}\n:::\n\n```{.r .cell-code}\n# Heap utilization vs dirty memory ratio\n\np_heap_dirty <- ggplot(\n  andmal_before,\n  aes(\n    x = heap_util,\n    y = dirty_ratio,\n    colour = fam_color\n  )\n) +\n  geom_point(alpha = 0.6, size = 1.2) +\n  facet_wrap(~ Category, scales = \"free\") +\n  scale_colour_identity(\n    name   = \"Family rank within category\",\n    breaks = c(\"red\", \"blue\", \"green\", \"yellow\", \"grey70\"),\n    labels = c(\"Top 1 family\", \"Top 2 family\",\n               \"Top 3 family\", \"Top 4 family\", \"Other families\"),\n    guide  = \"legend\"\n  ) +\n  labs(\n    title    = \"Heap utilization vs dirty memory ratio (before reboot)\",\n    subtitle = \"Points colored by top 4 families (per category); others in grey\",\n    x = \"Heap utilization = Memory_HeapAlloc / Memory_HeapSize\",\n    y = \"Dirty ratio = (Memory_PrivateDirty + Memory_SharedDirty) / Memory_PssTotal\"\n  ) +\n  andmal_theme\n\np_heap_dirty\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-3.png){width=960}\n:::\n\n```{.r .cell-code}\n# API sessions vs memory footprint\n\np_api_mem <- ggplot(\n  andmal_before,\n  aes(\n    x = log_API_sessions,\n    y = log_PssTotal,\n    colour = fam_color\n  )\n) +\n  geom_point(alpha = 0.6, size = 1.2) +\n  facet_wrap(~ Category, scales = \"free\") +\n  scale_colour_identity(\n    name   = \"Family rank within category\",\n    breaks = c(\"red\", \"blue\", \"green\", \"yellow\", \"grey70\"),\n    labels = c(\"Top 1 family\", \"Top 2 family\",\n               \"Top 3 family\", \"Top 4 family\", \"Other families\"),\n    guide  = \"legend\"\n  ) +\n  labs(\n    title    = \"API session activity vs memory footprint (before reboot)\",\n    subtitle = \"log10(API__sessions + 1) vs log10(Memory_PssTotal + 1), colored by top 4 families per category\",\n    x = \"log10(API__sessions + 1)\",\n    y = \"log10(Memory_PssTotal + 1)\"\n  ) +\n  andmal_theme\n\np_api_mem\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-4.png){width=960}\n:::\n\n```{.r .cell-code}\n#Webview UI plots\n\n# Long format + scaling per feature\nui_long <- andmal_before %>%\n  select(Category, Family, fam_color, all_of(ui_features)) %>%\n  pivot_longer(\n    cols = all_of(ui_features),\n    names_to = \"ui_feature\",\n    values_to = \"value\"\n  ) %>%\n  group_by(ui_feature) %>%\n  mutate(\n    value_scaled = (value - mean(value, na.rm = TRUE)) /\n                   sd(value, na.rm = TRUE)\n  ) %>%\n  ungroup()\n\n# Aggregate per Category x Family x feature\nui_family_summary <- ui_long %>%\n  group_by(Category, Family, fam_color, ui_feature) %>%\n  summarise(\n    mean_scaled = mean(value_scaled, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n# Order features for nicer X-axis\nui_family_summary <- ui_family_summary %>%\n  mutate(ui_feature = factor(ui_feature, levels = ui_features))\n\n# Parallel coordinates / radar-like plot\np_ui_parallel <- ggplot(\n  ui_family_summary,\n  aes(\n    x = ui_feature,\n    y = mean_scaled,\n    group = Family,\n    colour = fam_color\n  )\n) +\n  geom_line(alpha = 0.8) +\n  facet_wrap(~ Category, scales = \"free_y\") +\n  scale_colour_identity(\n    name   = \"Family rank within category\",\n    breaks = c(\"red\", \"blue\", \"green\", \"yellow\", \"grey70\"),\n    labels = c(\"Top 1 family\", \"Top 2 family\",\n               \"Top 3 family\", \"Top 4 family\", \"Other families\"),\n    guide  = \"legend\"\n  ) +\n  labs(\n    title    = \"UI / object graph profile by family (before reboot)\",\n    subtitle = \"Z-scored UI features; lines are families, colored by top-4 rank within each category\",\n    x = \"UI / object graph feature\",\n    y = \"Mean z-scored value\"\n  ) +\n  andmal_theme +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.minor.x = element_blank()\n  )\n\np_ui_parallel\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-5.png){width=960}\n:::\n\n```{.r .cell-code}\np_webview_activities <- ggplot(\n  andmal_before,\n  aes(\n    x = Memory_Activities,\n    y = Memory_WebViews,\n    colour = fam_color\n  )\n) +\n  geom_point(alpha = 0.6, size = 1.2) +\n  facet_wrap(~ Category, scales = \"free\") +\n  scale_colour_identity(\n    name   = \"Family rank within category\",\n    breaks = c(\"red\", \"blue\", \"green\", \"yellow\", \"grey70\"),\n    labels = c(\"Top 1 family\", \"Top 2 family\",\n               \"Top 3 family\", \"Top 4 family\", \"Other families\"),\n    guide  = \"legend\"\n  ) +\n  labs(\n    title    = \"WebView usage vs Activities (before reboot)\",\n    subtitle = \"Per sample; facets are malware categories, colors show top 4 families in each category\",\n    x = \"Memory_Activities\",\n    y = \"Memory_WebViews\"\n  ) +\n  andmal_theme\n\np_webview_activities\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-6.png){width=960}\n:::\n\n```{.r .cell-code}\n# Processes and API calls\n\napi_proc_features <- c(\n  \"API_Process_android.os.Process_start\",\n  \"API_Process_android.app.ActivityManager_killBackgroundProcesses\",\n  \"API_Process_android.os.Process_killProcess\",\n  \"API_Command_java.lang.Runtime_exec\",\n  \"API_Command_java.lang.ProcessBuilder_start\",\n  \"API_JavaNativeInterface_java.lang.Runtime_loadLibrary\",\n  \"API_JavaNativeInterface_java.lang.Runtime_load\"\n)\n\n# Group them semantically\napi_proc_groups <- list(\n  ProcessMgmt = c(\n    \"API_Process_android.os.Process_start\",\n    \"API_Process_android.app.ActivityManager_killBackgroundProcesses\",\n    \"API_Process_android.os.Process_killProcess\"\n  ),\n  CommandExec = c(\n    \"API_Command_java.lang.Runtime_exec\",\n    \"API_Command_java.lang.ProcessBuilder_start\"\n  ),\n  NativeLoad = c(\n    \"API_JavaNativeInterface_java.lang.Runtime_loadLibrary\",\n    \"API_JavaNativeInterface_java.lang.Runtime_load\"\n  )\n)\n\n# API Behavior fingerprint\nproc_presence <- andmal_before %>%\n  select(Category, all_of(api_proc_features)) %>%\n  mutate(\n    across(\n      all_of(api_proc_features),\n      ~ as.integer(. > 0)  # 1 if API was ever called, else 0\n    )\n  ) %>%\n  pivot_longer(\n    cols = all_of(api_proc_features),\n    names_to = \"api_call\",\n    values_to = \"present\"\n  ) %>%\n  group_by(Category, api_call) %>%\n  summarise(\n    prop_present = mean(present, na.rm = TRUE),\n    n_samples    = n(),\n    .groups      = \"drop\"\n  ) %>%\n  mutate(\n    api_call = factor(api_call, levels = api_proc_features)\n  )\n\n# Heatmap: API × Category ----\np_proc_heatmap <- ggplot(\n  proc_presence,\n  aes(x = Category, y = api_call, fill = prop_present)\n) +\n  geom_tile(color = \"white\") +\n  scale_fill_viridis_c(\n    name   = \"% samples using API\",\n    labels = label_percent(accuracy = 1)\n  ) +\n  labs(\n    title    = \"Process & native execution APIs by malware category (before reboot)\",\n    subtitle = \"Each cell shows the percentage of samples in a category that used the given API at least once\",\n    x = \"Malware category\",\n    y = \"API call\"\n  ) +\n  andmal_theme +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid  = element_blank()\n  )\n\np_proc_heatmap\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-7.png){width=960}\n:::\n\n```{.r .cell-code}\n# Process manipulation index by category\n\n# For each sample, flag whether it used any API in each group ----\nproc_groups_long <- andmal_before %>%\n  select(Category, all_of(unique(unlist(api_proc_groups)))) %>%\n  mutate(\n    ProcessMgmt = as.integer(\n      rowSums(across(all_of(api_proc_groups$ProcessMgmt), ~ . > 0), na.rm = TRUE) > 0\n    ),\n    CommandExec = as.integer(\n      rowSums(across(all_of(api_proc_groups$CommandExec), ~ . > 0), na.rm = TRUE) > 0\n    ),\n    NativeLoad = as.integer(\n      rowSums(across(all_of(api_proc_groups$NativeLoad), ~ . > 0), na.rm = TRUE) > 0\n    )\n  ) %>%\n  select(Category, ProcessMgmt, CommandExec, NativeLoad) %>%\n  pivot_longer(\n    cols      = c(ProcessMgmt, CommandExec, NativeLoad),\n    names_to  = \"group\",\n    values_to = \"present\"\n  )\n\n# Proportion of samples in each Category that have ≥1 call in each group ----\nproc_group_summary <- proc_groups_long %>%\n  group_by(Category, group) %>%\n  summarise(\n    prop_present = mean(present, na.rm = TRUE),\n    n_samples    = n(),\n    .groups      = \"drop\"\n  )\n\n# Stacked bar: process manipulation index by category ----\np_proc_groups <- ggplot(\n  proc_group_summary,\n  aes(x = Category, y = prop_present, fill = group)\n) +\n  geom_col(position = \"stack\") +  # use 'position = \"dodge\"' if you prefer side-by-side\n  scale_fill_viridis_d(\n    option = \"D\",\n    end    = 0.9,\n    name   = \"API group\",\n    labels = c(\n      ProcessMgmt = \"Process management (start/kill)\",\n      CommandExec = \"Command execution\",\n      NativeLoad  = \"Native code loading\"\n    )\n  ) +\n  scale_y_continuous(labels = label_percent(accuracy = 1)) +\n  labs(\n    title    = \"Process manipulation index by malware category (before reboot)\",\n    subtitle = \"Each segment = proportion of samples with ≥1 call in that API group\\nNote: segments can overlap, so bars may exceed 100% height\",\n    x = \"Malware category\",\n    y = \"Proportion of samples\"\n  ) +\n  andmal_theme +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  )\n\np_proc_groups\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-8.png){width=960}\n:::\n\n```{.r .cell-code}\n# Scatterplot: network bytes vs WebView calls\np_net_webview <- ggplot(\n  andmal_before,\n  aes(\n    x = log_NetTxBytes,\n    y = log_WebView_calls,\n    colour = fam_color\n  )\n) +\n  geom_point(alpha = 0.6, size = 1.2) +\n  facet_wrap(~ Category, scales = \"free\") +\n  scale_colour_identity(\n    name   = \"Family rank within category\",\n    breaks = c(\"red\", \"blue\", \"green\", \"yellow\", \"grey70\"),\n    labels = c(\"Top 1 family\", \"Top 2 family\",\n               \"Top 3 family\", \"Top 4 family\", \"Other families\"),\n    guide  = \"legend\"\n  ) +\n  labs(\n    title    = \"Network activity vs WebView usage (before reboot)\",\n    subtitle = \"log10(Network_TotalTransmittedBytes + 1) vs log10(total WebView calls), facetted by category\\nTop 4 families in each category highlighted in red/blue/green/yellow\",\n    x = \"log10(Network_TotalTransmittedBytes + 1)\",\n    y = \"log10(total WebView API calls + 1)\"\n  ) +\n  andmal_theme\n\np_net_webview\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-9.png){width=960}\n:::\n\n```{.r .cell-code}\n# Violin: network throughput by Category (TX & RX)\n\np_net_tx_violin <- ggplot(\n  get_combined_data(),\n  aes(x = Category, y = log_NetTxBytes, fill = Category)\n) +\n  geom_violin(trim = FALSE, alpha = 0.8) +\n  labs(\n    title    = \"Network throughput (transmitted bytes) by malware category\",\n    subtitle = \"log10(Network_TotalTransmittedBytes + 1)\",\n    x = \"Malware category\",\n    y = \"log10(Network_TotalTransmittedBytes + 1)\"\n  ) +\n  category_fill +   # from earlier: scale_fill_viridis_d(...)\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_net_tx_violin\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-10.png){width=960}\n:::\n\n```{.r .cell-code}\n# Received bytes ----\np_net_rx_violin <- ggplot(\n  get_combined_data(),\n  aes(x = Category, y = log_NetRxBytes, fill = Category)\n) +\n  geom_violin(trim = FALSE, alpha = 0.8) +\n  labs(\n    title    = \"Network throughput (received bytes) by malware category\",\n    subtitle = \"log10(Network_TotalReceivedBytes + 1)\",\n    x = \"Malware category\",\n    y = \"log10(Network_TotalReceivedBytes + 1)\"\n  ) +\n  category_fill +\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_net_rx_violin\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-11.png){width=960}\n:::\n\n```{.r .cell-code}\n# Before vs after reboot: boxplots of network TX by Category\n\np_net_tx_box_reboot <- ggplot(\n  get_combined_data(),\n  aes(x = Category, y = log_NetTxBytes, fill = reboot_state)\n) +\n  geom_boxplot(outlier.alpha = 0.3, position = position_dodge(width = 0.8)) +\n  labs(\n    title    = \"Network transmitted bytes: before vs after reboot\",\n    subtitle = \"log10(Network_TotalTransmittedBytes + 1), side-by-side by reboot state\",\n    x = \"Malware category\",\n    y = \"log10(Network_TotalTransmittedBytes + 1)\",\n    fill = \"Reboot state\"\n  ) +\n  scale_fill_manual(\n    values = c(\"Before reboot\" = \"#440154FF\", \"After reboot\" = \"#21908CFF\")\n  ) +\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_net_tx_box_reboot\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-12.png){width=960}\n:::\n\n```{.r .cell-code}\n# 1) Category-level means for all File/DB APIs ----\nfiledb_means <- get_combined_data() %>%\n  select(Category, all_of(filedb_apis)) %>%\n  group_by(Category) %>%\n  summarise(\n    across(everything(), ~ mean(.x, na.rm = TRUE)),\n    .groups = \"drop\"\n  )\n\n# Turn into matrix: rows = Categories, cols = APIs ----\nfiledb_mat <- filedb_means %>%\n  column_to_rownames(\"Category\") %>%\n  as.matrix()\n\n# Replace NaN/Inf (e.g., mean of all-NA column) with 0 ----\nfiledb_mat[!is.finite(filedb_mat)] <- 0\n\n# 2) Drop APIs with zero variance (no information) ----\ncol_sds <- apply(filedb_mat, 2, sd, na.rm = TRUE)\n\nkeep_cols <- names(col_sds)[col_sds > 0 & !is.na(col_sds)]\nfiledb_mat2 <- filedb_mat[, keep_cols, drop = FALSE]\n\n# 3) Z-score across categories per API ----\nfiledb_mat_scaled <- scale(filedb_mat2)  # center & scale each column\n\n# 4) Hierarchical clustering on rows (Categories) and columns (APIs) ----\nrow_clust <- hclust(dist(filedb_mat_scaled))\ncol_clust <- hclust(dist(t(filedb_mat_scaled)))\n\nrow_order <- rownames(filedb_mat_scaled)[row_clust$order]\ncol_order <- colnames(filedb_mat_scaled)[col_clust$order]\n\n# 5) Long format for ggplot, using clustered ordering ----\nfiledb_long <- as.data.frame(filedb_mat_scaled) %>%\n  rownames_to_column(\"Category\") %>%\n  pivot_longer(\n    cols      = -Category,\n    names_to  = \"api_call\",\n    values_to = \"z_mean_calls\"\n  ) %>%\n  mutate(\n    Category = factor(Category, levels = row_order),\n    api_call = factor(api_call, levels = col_order)\n  )\n\n# 6) Heatmap ----\np_filedb_heatmap <- ggplot(\n  filedb_long,\n  aes(x = Category, y = api_call, fill = z_mean_calls)\n) +\n  geom_tile(color = \"white\") +\n  scale_fill_viridis_c(\n    option = \"B\",\n    name   = \"Z-scored\\nmean calls\"\n  ) +\n  labs(\n    title    = \"File I/O and database activity by malware category\",\n    subtitle = \"Z-scored mean call counts per API; APIs with no variance removed, rows/cols clustered\",\n    x = \"Malware category\",\n    y = \"File / DB API\"\n  ) +\n  andmal_theme +\n  theme(\n    panel.grid = element_blank()\n  )\n\np_filedb_heatmap\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-13.png){width=960}\n:::\n\n```{.r .cell-code}\n# Heatmap All categories: reads vs writes ---- \np_db_read_write <- ggplot(\n  get_combined_data(),\n  aes(x = log_DB_reads, y = log_DB_writes)\n) +\n  stat_density_2d(aes(fill = after_stat(level)), geom = \"polygon\", alpha = 0.8) +\n  scale_fill_viridis_c(option = \"inferno\", name = \"Density\") +\n  labs(\n    title    = \"Database read vs write activity\",\n    subtitle = \"log10(total DB reads + 1) vs log10(total DB writes + 1) per sample\",\n    x = \"log10(total DB read calls + 1)\",\n    y = \"log10(total DB write calls + 1)\"\n  ) +\n  andmal_theme\n\np_db_read_write\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-14.png){width=960}\n:::\n\n```{.r .cell-code}\n# Heatmap Facet: reads vs writes ---- \np_db_read_write_fam <- ggplot(\n  andmal_before,\n  aes(x = log_DB_reads, y = log_DB_writes)\n) +\n  stat_density_2d(aes(fill = after_stat(level)), geom = \"polygon\", alpha = 0.8) +\n  facet_wrap(~ Category, scales = \"free\") +\n  scale_fill_viridis_c(option = \"inferno\", name = \"Density\") +\n  labs(\n    title    = \"Database read vs write activity (before reboot)\",\n    subtitle = \"log10(total DB reads + 1) vs log10(total DB writes + 1), facetted by category\",\n    x = \"log10(total DB read calls + 1)\",\n    y = \"log10(total DB write calls + 1)\"\n  ) +\n  andmal_theme\n\np_db_read_write_fam\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `stat_contour()`: Zero contours were generated\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-15.png){width=960}\n:::\n\n```{.r .cell-code}\n## 2. Keep only those Dex columns that actually exist in your data ----\n# (Optional) See which ones were missing:\nsetdiff(dex_apis, names(andmal_before))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"API_DexClassLoader_dalvik.system.DexClassLoader_.init\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# You can inspect this in the console if you're curious.\n\n## 3. Summarise per Category: proportion of samples with any Dex loading ----\n# (Moved to index.qmd)\n\n\n# Cryptography and Encryption\n\np_crypto_intensity <- ggplot(\n  get_combined_data(),\n  aes(x = Category, y = log_crypto, fill = Category)\n) +\n  geom_violin(trim = FALSE, alpha = 0.8) +\n  category_fill +\n  labs(\n    title    = \"Crypto intensity by malware category\",\n    subtitle = \"log10(total crypto-related API calls + 1)\\nCrypto APIs: Cipher_doFinal, MessageDigest_*, SecretKeySpec_.init\",\n    x = \"Malware category\",\n    y = \"log10(crypto_calls + 1)\"\n  ) +\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_crypto_intensity\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-16.png){width=960}\n:::\n\n```{.r .cell-code}\np_crypto_base64 <- ggplot(\n  get_combined_data(),\n  aes(\n    x = log_base64,\n    y = log_crypto,\n    colour = Category\n  )\n) +\n  geom_point(alpha = 0.6, size = 1.2) +\n  category_col +\n  labs(\n    title    = \"Crypto vs Base64 usage by malware category\",\n    subtitle = \"log10(total Base64 calls + 1) vs log10(total crypto calls + 1)\",\n    x = \"log10(Base64_calls + 1)\",\n    y = \"log10(crypto_calls + 1)\"\n  ) +\n  andmal_theme\n\np_crypto_base64\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/plot-memory-17.png){width=960}\n:::\n\n```{.r .cell-code}\n#IPC/Binder plots\n```\n:::\n\n\n### IPC/Binder plots\n\nWe'll group APIs into 4 behaviors:\n\nBroadcasts - sendBroadcast / sendStickyBroadcast\n\nServices - startService / stopService\n\nReceivers - any *_registerReceiver / ActivityThread_handleReceiver\n\nActivities - any *_startActivity\n\nThen compute, for each Category, the proportion of samples that use each behavior at least once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Build per-sample flags for each IPC behavior group ----\nipc_group_summary <- get_combined_data() %>%\n  select(Category, has_broadcast, has_service, has_receiver, has_activity) %>%\n  pivot_longer(\n    cols      = c(has_broadcast, has_service, has_receiver, has_activity),\n    names_to  = \"ipc_group\",\n    values_to = \"present\"\n  ) %>%\n  mutate(\n    ipc_group = recode(\n      ipc_group,\n      has_broadcast = \"Broadcasts\",\n      has_service   = \"Services\",\n      has_receiver  = \"Receivers\",\n      has_activity  = \"Activities\"\n    )\n  ) %>%\n  group_by(Category, ipc_group) %>%\n  summarise(\n    prop_present = mean(present, na.rm = TRUE),\n    n_samples    = n(),\n    .groups      = \"drop\"\n  )\n\n# Bar chart: proportion by Category & IPC group ----\np_ipc_groups <- ggplot(\n  ipc_group_summary,\n  aes(x = Category, y = prop_present, fill = ipc_group)\n) +\n  geom_col(position = \"dodge\") +\n  scale_y_continuous(\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_fill_viridis_d(\n    option = \"D\",\n    end    = 0.9,\n    name   = \"IPC/Binder behavior\"\n  ) +\n  labs(\n    title    = \"IPC, Binder & broadcast behavior by malware category\",\n    subtitle = \"Proportion of samples that use each IPC group at least once\",\n    x = \"Malware category\",\n    y = \"% of samples\"\n  ) +\n  andmal_theme +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  )\n\np_ipc_groups\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/ipc-behaviors-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Privacy\np_pii_index <- ggplot(\n  get_combined_data(),\n  aes(x = Category, y = log_PII_access, fill = Category)\n) +\n  geom_violin(trim = FALSE, alpha = 0.8) +\n  category_fill +\n  labs(\n    title    = \"PII access intensity by malware category\",\n    subtitle = \"log10(PII_access_count + 1), where PII = IDs + accounts + location + mic calls\",\n    x = \"Malware category\",\n    y = \"log10(PII_access_count + 1)\"\n  ) +\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_pii_index\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/ipc-behaviors-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Long + summary for PII type proportions\npii_long <- get_combined_data() %>%\n  select(Category, has_ids, has_accounts, has_location, has_mic) %>%\n  pivot_longer(\n    cols      = c(has_ids, has_accounts, has_location, has_mic),\n    names_to  = \"pii_type\",\n    values_to = \"present\"\n  ) %>%\n  mutate(\n    pii_type = recode(\n      pii_type,\n      has_ids      = \"Identifiers (device + WiFi)\",\n      has_accounts = \"Accounts & content\",\n      has_location = \"Location\",\n      has_mic      = \"Microphone\"\n    )\n  )\n\npii_summary <- pii_long %>%\n  group_by(Category, pii_type) %>%\n  summarise(\n    prop_present = mean(present, na.rm = TRUE),\n    n_samples    = n(),\n    .groups      = \"drop\"\n  )\n\n# Stacked bar per Category: what PII is accessed?\np_pii_type <- ggplot(\n  pii_summary,\n  aes(x = Category, y = prop_present, fill = pii_type)\n) +\n  geom_col(position = \"stack\") +\n  scale_y_continuous(\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_fill_viridis_d(\n    option = \"D\",\n    end    = 0.9,\n    name   = \"PII type\"\n  ) +\n  labs(\n    title    = \"Types of PII accessed by malware category\",\n    subtitle = \"Each bar shows the proportion of samples accessing different PII types (may overlap)\",\n    x = \"Malware category\",\n    y = \"% of samples\"\n  ) +\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_pii_type\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/ipc-behaviors-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# Long format for location/mic + reboot_state\nloc_mic_long <- get_combined_data() %>%\n  mutate(\n    has_location = location_calls > 0,\n    has_mic      = mic_calls      > 0\n  ) %>%\n  select(Category, reboot_state, has_location, has_mic) %>%\n  pivot_longer(\n    cols      = c(has_location, has_mic),\n    names_to  = \"sensor_type\",\n    values_to = \"present\"\n  ) %>%\n  mutate(\n    sensor_type = recode(\n      sensor_type,\n      has_location = \"Location\",\n      has_mic      = \"Microphone\"\n    )\n  )\n\nloc_mic_summary <- loc_mic_long %>%\n  group_by(Category, reboot_state, sensor_type) %>%\n  summarise(\n    prop_present = mean(present, na.rm = TRUE),\n    n_samples    = n(),\n    .groups      = \"drop\"\n  )\n\n# Bar chart: before vs after reboot for location/mic\np_loc_mic_reboot <- ggplot(\n  loc_mic_summary,\n  aes(x = Category, y = prop_present, fill = reboot_state)\n) +\n  geom_col(position = \"dodge\") +\n  facet_wrap(~ sensor_type) +\n  scale_y_continuous(\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_fill_manual(\n    values = c(\"Before reboot\" = \"#440154FF\", \"After reboot\" = \"#21908CFF\"),\n    name   = \"Reboot state\"\n  ) +\n  labs(\n    title    = \"Location and microphone access: before vs after reboot\",\n    subtitle = \"Proportion of samples touching location/mic APIs, by category & reboot state\",\n    x = \"Malware category\",\n    y = \"% of samples\"\n  ) +\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_loc_mic_reboot\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/ipc-behaviors-4.png){width=672}\n:::\n\n```{.r .cell-code}\np_log_process <- ggplot(\n  get_combined_data(),\n  aes(\n    x = log_Process_total,\n    y = log_Logcat_total,\n    colour = Category\n  )\n) +\n  geom_point(alpha = 0.6, size = 1.2) +\n  facet_wrap(~ reboot_state) +\n  category_col +\n  labs(\n    title    = \"Logcat volume vs process activity\",\n    subtitle = \"log10(Process_total + 1) vs log10(Logcat_total + 1), facetted by reboot state\",\n    x = \"log10(Process_total + 1)\",\n    y = \"log10(Logcat_total + 1)\"\n  ) +\n  andmal_theme\n\np_log_process\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/ipc-behaviors-5.png){width=672}\n:::\n\n```{.r .cell-code}\nbattery_long <- get_combined_data() %>%\n  select(Category, Battery_wakelock, Battery_service) %>%\n  pivot_longer(\n    cols      = c(Battery_wakelock, Battery_service),\n    names_to  = \"battery_metric\",\n    values_to = \"value\"\n  ) %>%\n  mutate(\n    battery_metric = recode(\n      battery_metric,\n      Battery_wakelock = \"Wakelock count\",\n      Battery_service  = \"Battery service events\"\n    )\n  )\n\np_battery <- ggplot(\n  battery_long,\n  aes(x = Category, y = value, fill = Category)\n) +\n  geom_boxplot(outlier.alpha = 0.3) +\n  facet_wrap(~ battery_metric, scales = \"free_y\") +\n  category_fill +\n  labs(\n    title    = \"Battery-related behavior by malware category\",\n    subtitle = \"Battery_wakelock and Battery_service distributions per category\",\n    x = \"Malware category\",\n    y = \"Value\"\n  ) +\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_battery\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/ipc-behaviors-6.png){width=672}\n:::\n\n```{.r .cell-code}\nlog_level_sums <- get_combined_data() %>%\n  group_by(Category) %>%\n  summarise(\n    error   = sum(Logcat_error,   na.rm = TRUE),\n    warning = sum(Logcat_warning, na.rm = TRUE),\n    info    = sum(Logcat_info,    na.rm = TRUE),\n    debug   = sum(Logcat_debug,   na.rm = TRUE),\n    verbose = sum(Logcat_verbose, na.rm = TRUE),\n    .groups = \"drop\"\n  ) %>%\n  pivot_longer(\n    cols      = c(error, warning, info, debug, verbose),\n    names_to  = \"log_level\",\n    values_to = \"count\"\n  ) %>%\n  group_by(Category) %>%\n  mutate(\n    total = sum(count, na.rm = TRUE),\n    frac  = if_else(total > 0, count / total, 0)\n  ) %>%\n  ungroup() %>%\n  mutate(\n    log_level = factor(\n      log_level,\n      levels = c(\"error\", \"warning\", \"info\", \"debug\", \"verbose\"),\n      labels = c(\"Error\", \"Warning\", \"Info\", \"Debug\", \"Verbose\")\n    )\n  )\n\np_log_levels <- ggplot(\n  log_level_sums,\n  aes(x = Category, y = frac, fill = log_level)\n) +\n  geom_col(position = \"stack\") +\n  scale_y_continuous(\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_fill_viridis_d(\n    option = \"D\",\n    end    = 0.9,\n    name   = \"Log level\"\n  ) +\n  labs(\n    title    = \"Log level composition by malware category\",\n    subtitle = \"Fraction of log messages by level (aggregated across samples)\",\n    x = \"Malware category\",\n    y = \"% of log messages\"\n  ) +\n  andmal_theme +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\np_log_levels\n```\n\n::: {.cell-output-display}\n![](proposal_files/figure-html/ipc-behaviors-7.png){width=672}\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}