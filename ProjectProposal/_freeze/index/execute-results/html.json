{
  "hash": "1e31bd8e923847060e91b7a7c304055f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Android Malware Classification\"\nformat: html\n---\n\n## Project Overview\n\nThis project applies machine learning techniques to classify Android malware samples by category and family using features extracted from dynamic analysis.\n\n### Research Questions\n\nHow imbalanced are the various categories and families of malware? What sort of permissions and API calls are most distinctive for each? What about memory/battery usage or network profiles?\n\n### Dataset\n\nWe use the **AndMal2020** dataset collected by UNB's Canadian Institute for Cybersecurity. The dataset includes dynamic analysis results of Android samples across multiple malware categories including Adware, Banking malware, SMS malware, Riskware, Backdoor, Ransomware, Trojan, and others.\n\n**Key Statistics:**\n- Over 25,000 samples analyzed\n- Features captured include system calls, API calls, memory usage, network activity, and more\n- Data collected both before and after device reboot\n\n## Database Activity Analysis\n\nDatabase activity patterns reveal distinct read-write relationships across malware categories. The density heatmap highlights regions of concentrated activity, showing how different malware types utilize database operations differently.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(viridis)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: viridisLite\n```\n\n\n:::\n\n```{.r .cell-code}\n# Load preprocessed data\nandmal_after <- readRDS(\"data/processed/andmal_after.rds\")\n\n# Load andmal_before if it exists, otherwise use empty dataframe\nif (file.exists(\"data/processed/andmal_before.rds\")) {\n  andmal_before <- readRDS(\"data/processed/andmal_before.rds\")\n} else {\n  # Create empty dataframe with same structure if file doesn't exist\n  andmal_before <- andmal_after[0, ]\n  cat(\"Note: andmal_before.rds not found, using only andmal_after data\\n\")\n}\n\n# Helper function to combine dataframes\nget_combined_data <- function() {\n  if (nrow(andmal_before) > 0) {\n    bind_rows(\n      andmal_before,\n      andmal_after\n    ) %>%\n    mutate(reboot_state = factor(reboot_state, levels = c(\"Before reboot\", \"After reboot\")))\n  } else {\n    andmal_after %>%\n    mutate(reboot_state = factor(reboot_state, levels = c(\"Before reboot\", \"After reboot\")))\n  }\n}\n\n# Create database read vs write heatmap\np_db_read_write_heatmap <- ggplot(\n  get_combined_data(),\n  aes(x = log_DB_reads, y = log_DB_writes)\n) +\n  stat_density_2d(aes(fill = after_stat(level)), geom = \"polygon\", alpha = 0.8) +\n  scale_fill_viridis_c(option = \"inferno\", name = \"Density\") +\n  labs(\n    title = \"Database read vs write activity\",\n    subtitle = \"log10(total DB reads + 1) vs log10(total DB writes + 1) per sample\",\n    x = \"log10(total DB read calls + 1)\",\n    y = \"log10(total DB write calls + 1)\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0),\n    plot.subtitle = element_text(hjust = 0)\n  )\n\np_db_read_write_heatmap\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/database-heatmap-1.png){width=672}\n:::\n:::\n\n\n## Methodology\n\n### 1. Data Preprocessing\n\nAll data loading and feature engineering is performed in [Preprocessing](preprocessing.qmd), which:\n\n- Loads raw CSV files from the AndMal2020 dataset\n- Creates derived features including:\n  - Memory utilization metrics\n  - Network activity summaries\n  - Database access patterns\n  - Cryptographic operations\n  - Privacy-related API calls\n  - IPC/Binder behaviors\n\n### 2. Category Prediction\n\nThe [Category Prediction](category.qmd) model uses a random forest classifier to predict malware category (e.g., Adware, Trojan, Riskware) from behavioral features.\n\n### 3. Family Prediction\n\nThe [Family Prediction](family.qmd) models train separate random forest classifiers for each major category (Adware, Riskware, Trojan) to predict specific malware families within those categories.\n\n### 4. Exploratory Analysis\n\n[Exploratory Analysis](proposal.qmd) provides visualizations and statistical summaries of the dataset, including distributions, feature relationships, and category comparisons.\n\n## Navigation\n\n- **[Preprocessing](preprocessing.qmd)** - Data loading and feature engineering\n- **[Category Prediction](category.qmd)** - Malware category classification model\n- **[Family Prediction](family.qmd)** - Malware family classification models\n- **[Exploratory Analysis](proposal.qmd)** - Data visualizations and EDA\n\n## Tools & Technologies\n\n- **R** - Data processing and analysis\n- **ranger** - Random forest implementation\n- **tidyverse** - Data manipulation and visualization\n- **Quarto** - Reproducible research documentation\n\n## References\n\n- [AndMal2020 Dataset](https://www.unb.ca/cic/datasets/andmal2020.html)\n- [MalDroid-2020 Dataset](https://www.unb.ca/cic/datasets/maldroid-2020.html)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}