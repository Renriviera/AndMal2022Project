---
title: "Android Malware Classification"
format: html
---

## Project Overview

This project applies machine learning techniques to classify Android malware samples by category and family using features extracted from dynamic analysis.

### Research Questions

How imbalanced are the various categories and families of malware? What sort of permissions and API calls are most distinctive for each? What about memory/battery usage or network profiles?

### Dataset

We use the **AndMal2020** dataset collected by UNB's Canadian Institute for Cybersecurity. The dataset includes dynamic analysis results of Android samples across multiple malware categories including Adware, Banking malware, SMS malware, Riskware, Backdoor, Ransomware, Trojan, and others.

**Key Statistics:**
- Over 25,000 samples analyzed
- Features captured include system calls, API calls, memory usage, network activity, and more
- Data collected both before and after device reboot

## Database Activity Analysis

Database activity patterns reveal distinct read-write relationships across malware categories. The density heatmap highlights regions of concentrated activity, showing how different malware types utilize database operations differently.

```{r}
#| label: database-heatmap
#| cache: true

library(ggplot2)
library(dplyr)
library(viridis)

# Load preprocessed data
andmal_after <- readRDS("data/processed/andmal_after.rds")
andmal_before <- readRDS("data/processed/andmal_before.rds")

# Helper function to combine dataframes
get_combined_data <- function() {
  bind_rows(
    andmal_before,
    andmal_after
  ) %>%
  mutate(reboot_state = factor(reboot_state, levels = c("Before reboot", "After reboot")))
}

# Create database read vs write heatmap
p_db_read_write_heatmap <- ggplot(
  get_combined_data(),
  aes(x = log_DB_reads, y = log_DB_writes)
) +
  stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", alpha = 0.8) +
  scale_fill_viridis_c(option = "inferno", name = "Density") +
  labs(
    title = "Database read vs write activity",
    subtitle = "log10(total DB reads + 1) vs log10(total DB writes + 1) per sample",
    x = "log10(total DB read calls + 1)",
    y = "log10(total DB write calls + 1)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0),
    plot.subtitle = element_text(hjust = 0)
  )

p_db_read_write_heatmap
```

## Dynamic Code Loading Analysis

Dynamic code loading through DexClassLoader APIs varies significantly across malware categories, with some categories showing higher adoption rates than others. This analysis examines the prevalence of dynamic code loading techniques used by different malware types.

```{r}
#| label: dynamic-dex-chart
#| cache: true

library(ggplot2)
library(dplyr)
library(scales)

# Load preprocessed data
andmal_after <- readRDS("data/processed/andmal_after.rds")
andmal_before <- readRDS("data/processed/andmal_before.rds")

# Helper function to combine dataframes
get_combined_data <- function() {
  bind_rows(
    andmal_before,
    andmal_after
  ) %>%
  mutate(reboot_state = factor(reboot_state, levels = c("Before reboot", "After reboot")))
}

# Summarise per Category: proportion of samples with any Dex loading
dex_summary <- get_combined_data() %>%
  group_by(Category) %>%
  summarise(
    prop_dex_any = mean(dex_any, na.rm = TRUE),
    n_samples    = n(),
    .groups      = "drop"
  )

# Bar chart: % of apps using Dex loading, by Category
p_dex_bar <- ggplot(
  dex_summary,
  aes(x = Category, y = prop_dex_any, fill = Category)
) +
  geom_col() +
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_manual(values = rep("red", length(unique(dex_summary$Category)))) +
  labs(
    title = "Dynamic Dex loading by malware category",
    subtitle = "Percentage of samples that use any DexClassLoader / DexFile dynamic loading API",
    x = "Malware category",
    y = "% of samples with dynamic Dex loading"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0),
    plot.subtitle = element_text(hjust = 0),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )

p_dex_bar
```

## Methodology

### 1. Data Preprocessing

All data loading and feature engineering is performed in [Preprocessing](preprocessing.qmd), which:

- Loads raw CSV files from the AndMal2020 dataset
- Creates derived features including:
  - Memory utilization metrics
  - Network activity summaries
  - Database access patterns
  - Cryptographic operations
  - Privacy-related API calls
  - IPC/Binder behaviors

### 2. Category Prediction

The [Category Prediction](category.qmd) model uses a random forest classifier to predict malware category (e.g., Adware, Trojan, Riskware) from behavioral features.

### 3. Family Prediction

The [Family Prediction](family.qmd) models train separate random forest classifiers for each major category (Adware, Riskware, Trojan) to predict specific malware families within those categories.

### 4. Exploratory Analysis

[Exploratory Analysis](proposal.qmd) provides visualizations and statistical summaries of the dataset, including distributions, feature relationships, and category comparisons.

## Navigation

- **[Preprocessing](preprocessing.qmd)** - Data loading and feature engineering
- **[Category Prediction](category.qmd)** - Malware category classification model
- **[Family Prediction](family.qmd)** - Malware family classification models
- **[Exploratory Analysis](proposal.qmd)** - Data visualizations and EDA

## Tools & Technologies

- **R** - Data processing and analysis
- **ranger** - Random forest implementation
- **tidyverse** - Data manipulation and visualization
- **Quarto** - Reproducible research documentation

## References

- [AndMal2020 Dataset](https://www.unb.ca/cic/datasets/andmal2020.html)
- [MalDroid-2020 Dataset](https://www.unb.ca/cic/datasets/maldroid-2020.html)

