---
title: "EDAV Proposal"
format: html
---

### Project Proposal:

EDAV project on android malware/benign code

I am interested in this area because I think cybersecurity does not get enough mainstream recognition- it is critical to the well-being of every other sector, it is also a data-rich(data quality is high too) computer centric field. Recently global events like the crowdstrike fiasco piqued my interest. I have always wanted to try doing some work in cybersecurity and this will be the first time! 
### Questions:
How imbalanced are the various categories and families of malware. What sort of permissions and API calls are most distinctive for each? What about memory/battery usage or network profiles?  Zero-days are never-seen before malware that exploit vulnerabilities previously unknown. There is also code that could not compile in the lab environment with reasons listed why. Should these be just considered as outliers or is there valuable knowledge to be gained from contrastive EDAV? 

### Datasets I plan to use(I will use the first link listed but listed other relevant ones as well):
https://www.unb.ca/cic/datasets/maldroid-2020.html
Collected by UNB's Canadian Institute for Cybersecurity from various(cited in the link) reputable sources.
— have access already, 17341 samples until 2018, 5 categories: Adware, Banking malware, SMS malware, Riskware, and Benign, APK files: 17,341 Android samples spanning between five distinct categories: Adware, Banking malware, SMS malware, Riskware, and Benign.
Capturing-logs: The output analysis results of 13,077 samples in five categories: Adware, Banking malware, SMS malware, Riskware, and Benign.
CSV files:
470 extracted features for 11,598 APK files comprising frequencies of system calls, binders, and composite behaviors
139 extracted features for 11,598 APK files comprising frequencies of system calls
50,621 extracted features for 11,598 APK files comprising static information, such as intent actions, permissions, intent consts, permissions, files, method tags, sensitive APIs, services, packages, receivers, etc.

### Other interesting sources:

https://www.unb.ca/cic/datasets/andmal2020.html 
— have access already,  big dataset 400k samples
https://androzoo.uni.lu/?utm_source=chatgpt.com
— don’t have access yes, very big dataset 20M+ samples
https://data.mendeley.com/datasets/rvjptkrc34/1
— have access already, small 1500 samples

### Load Libraries and Preprocessed Data

```{r}
#| label: load-libraries
#| cache: true

library(ggplot2)
library(tidyverse)
library(viridis)
library(dplyr)
library(scales)
library(tibble)
library(tidyr)
```

```{r}
#| label: load-processed-data
#| cache: true

# Load preprocessed data from preprocessing.qmd
andmal_after <- readRDS("data/processed/andmal_after.rds")
andmal_before <- readRDS("data/processed/andmal_before.rds")
feature_definitions <- readRDS("data/processed/feature_definitions.rds")

# Extract feature definitions for use in visualizations
ui_features <- feature_definitions$ui_features
dex_apis <- feature_definitions$dex_apis
webview_cols <- feature_definitions$webview_cols
fileio_apis <- feature_definitions$fileio_apis
db_apis <- feature_definitions$db_apis
db_read_apis <- feature_definitions$db_read_apis
db_write_apis <- feature_definitions$db_write_apis
filedb_apis <- feature_definitions$filedb_apis

# Global color scheme
andmal_theme <- theme_minimal(base_family = "sans") +
  theme(
    plot.title    = element_text(face = "bold", hjust = 0),
    plot.subtitle = element_text(hjust = 0),
    axis.text.x   = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )

category_col  <- scale_colour_viridis_d(option = "H", end = 0.9)
category_fill <- scale_fill_viridis_d(option = "H", end = 0.9)

cat(sprintf("Loaded andmal_after: %d rows, %d columns\n", nrow(andmal_after), ncol(andmal_after)))
cat(sprintf("Loaded andmal_before: %d rows, %d columns\n", nrow(andmal_before), ncol(andmal_before)))
```

## Visualizations

```{r}
#| label: helper-function
#| echo: false

# Helper function to combine dataframes when needed for plots
get_combined_data <- function() {
  bind_rows(
    andmal_before,
    andmal_after
  ) %>%
  mutate(reboot_state = factor(reboot_state, levels = c("Before reboot", "After reboot")))
}
```

### Memory Analysis

```{r}
#| label: plot-memory
#| fig-height: 6
#| fig-width: 10

# Boxplots memory footprint by category
p_mem <- ggplot(get_combined_data(), aes(x = Category, y = log_PssTotal, fill = Category)) +
  geom_boxplot(outlier.alpha = 0.3) +
  facet_wrap(~ reboot_state) +
  labs(
    title    = "Memory footprint by malware category",
    subtitle = "Memory_PssTotal on log10 scale, split by before/after reboot",
    x = "Malware category",
    y = "log10(Memory_PssTotal + 1)"
  ) +
  category_fill +
  andmal_theme

p_mem

# Process intensity by category

p_proc <- ggplot(get_combined_data(), aes(x = Category, y = log_Process_total, fill = Category)) +
  geom_boxplot(outlier.alpha = 0.3) +
  facet_wrap(~ reboot_state) +
  labs(
    title    = "Process intensity by malware category",
    subtitle = "Total number of processes (Process_total) on log10 scale",
    x = "Malware category",
    y = "log10(Process_total + 1)"
  ) +
  category_fill +
  andmal_theme

p_proc

# Heap utilization vs dirty memory ratio

p_heap_dirty <- ggplot(
  andmal_before,
  aes(
    x = heap_util,
    y = dirty_ratio,
    colour = fam_color
  )
) +
  geom_point(alpha = 0.6, size = 1.2) +
  facet_wrap(~ Category, scales = "free") +
  scale_colour_identity(
    name   = "Family rank within category",
    breaks = c("red", "blue", "green", "yellow", "grey70"),
    labels = c("Top 1 family", "Top 2 family",
               "Top 3 family", "Top 4 family", "Other families"),
    guide  = "legend"
  ) +
  labs(
    title    = "Heap utilization vs dirty memory ratio (before reboot)",
    subtitle = "Points colored by top 4 families (per category); others in grey",
    x = "Heap utilization = Memory_HeapAlloc / Memory_HeapSize",
    y = "Dirty ratio = (Memory_PrivateDirty + Memory_SharedDirty) / Memory_PssTotal"
  ) +
  andmal_theme

p_heap_dirty

# API sessions vs memory footprint

p_api_mem <- ggplot(
  andmal_before,
  aes(
    x = log_API_sessions,
    y = log_PssTotal,
    colour = fam_color
  )
) +
  geom_point(alpha = 0.6, size = 1.2) +
  facet_wrap(~ Category, scales = "free") +
  scale_colour_identity(
    name   = "Family rank within category",
    breaks = c("red", "blue", "green", "yellow", "grey70"),
    labels = c("Top 1 family", "Top 2 family",
               "Top 3 family", "Top 4 family", "Other families"),
    guide  = "legend"
  ) +
  labs(
    title    = "API session activity vs memory footprint (before reboot)",
    subtitle = "log10(API__sessions + 1) vs log10(Memory_PssTotal + 1), colored by top 4 families per category",
    x = "log10(API__sessions + 1)",
    y = "log10(Memory_PssTotal + 1)"
  ) +
  andmal_theme

p_api_mem

#Webview UI plots

# Long format + scaling per feature
ui_long <- andmal_before %>%
  select(Category, Family, fam_color, all_of(ui_features)) %>%
  pivot_longer(
    cols = all_of(ui_features),
    names_to = "ui_feature",
    values_to = "value"
  ) %>%
  group_by(ui_feature) %>%
  mutate(
    value_scaled = (value - mean(value, na.rm = TRUE)) /
                   sd(value, na.rm = TRUE)
  ) %>%
  ungroup()

# Aggregate per Category x Family x feature
ui_family_summary <- ui_long %>%
  group_by(Category, Family, fam_color, ui_feature) %>%
  summarise(
    mean_scaled = mean(value_scaled, na.rm = TRUE),
    .groups = "drop"
  )

# Order features for nicer X-axis
ui_family_summary <- ui_family_summary %>%
  mutate(ui_feature = factor(ui_feature, levels = ui_features))

# Parallel coordinates / radar-like plot
p_ui_parallel <- ggplot(
  ui_family_summary,
  aes(
    x = ui_feature,
    y = mean_scaled,
    group = Family,
    colour = fam_color
  )
) +
  geom_line(alpha = 0.8) +
  facet_wrap(~ Category, scales = "free_y") +
  scale_colour_identity(
    name   = "Family rank within category",
    breaks = c("red", "blue", "green", "yellow", "grey70"),
    labels = c("Top 1 family", "Top 2 family",
               "Top 3 family", "Top 4 family", "Other families"),
    guide  = "legend"
  ) +
  labs(
    title    = "UI / object graph profile by family (before reboot)",
    subtitle = "Z-scored UI features; lines are families, colored by top-4 rank within each category",
    x = "UI / object graph feature",
    y = "Mean z-scored value"
  ) +
  andmal_theme +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.minor.x = element_blank()
  )

p_ui_parallel

p_webview_activities <- ggplot(
  andmal_before,
  aes(
    x = Memory_Activities,
    y = Memory_WebViews,
    colour = fam_color
  )
) +
  geom_point(alpha = 0.6, size = 1.2) +
  facet_wrap(~ Category, scales = "free") +
  scale_colour_identity(
    name   = "Family rank within category",
    breaks = c("red", "blue", "green", "yellow", "grey70"),
    labels = c("Top 1 family", "Top 2 family",
               "Top 3 family", "Top 4 family", "Other families"),
    guide  = "legend"
  ) +
  labs(
    title    = "WebView usage vs Activities (before reboot)",
    subtitle = "Per sample; facets are malware categories, colors show top 4 families in each category",
    x = "Memory_Activities",
    y = "Memory_WebViews"
  ) +
  andmal_theme

p_webview_activities
# Processes and API calls

api_proc_features <- c(
  "API_Process_android.os.Process_start",
  "API_Process_android.app.ActivityManager_killBackgroundProcesses",
  "API_Process_android.os.Process_killProcess",
  "API_Command_java.lang.Runtime_exec",
  "API_Command_java.lang.ProcessBuilder_start",
  "API_JavaNativeInterface_java.lang.Runtime_loadLibrary",
  "API_JavaNativeInterface_java.lang.Runtime_load"
)

# Group them semantically
api_proc_groups <- list(
  ProcessMgmt = c(
    "API_Process_android.os.Process_start",
    "API_Process_android.app.ActivityManager_killBackgroundProcesses",
    "API_Process_android.os.Process_killProcess"
  ),
  CommandExec = c(
    "API_Command_java.lang.Runtime_exec",
    "API_Command_java.lang.ProcessBuilder_start"
  ),
  NativeLoad = c(
    "API_JavaNativeInterface_java.lang.Runtime_loadLibrary",
    "API_JavaNativeInterface_java.lang.Runtime_load"
  )
)

# API Behavior fingerprint
proc_presence <- andmal_before %>%
  select(Category, all_of(api_proc_features)) %>%
  mutate(
    across(
      all_of(api_proc_features),
      ~ as.integer(. > 0)  # 1 if API was ever called, else 0
    )
  ) %>%
  pivot_longer(
    cols = all_of(api_proc_features),
    names_to = "api_call",
    values_to = "present"
  ) %>%
  group_by(Category, api_call) %>%
  summarise(
    prop_present = mean(present, na.rm = TRUE),
    n_samples    = n(),
    .groups      = "drop"
  ) %>%
  mutate(
    api_call = factor(api_call, levels = api_proc_features)
  )

# Heatmap: API × Category ----
p_proc_heatmap <- ggplot(
  proc_presence,
  aes(x = Category, y = api_call, fill = prop_present)
) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(
    name   = "% samples using API",
    labels = label_percent(accuracy = 1)
  ) +
  labs(
    title    = "Process & native execution APIs by malware category (before reboot)",
    subtitle = "Each cell shows the percentage of samples in a category that used the given API at least once",
    x = "Malware category",
    y = "API call"
  ) +
  andmal_theme +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid  = element_blank()
  )

p_proc_heatmap
# Process manipulation index by category

# For each sample, flag whether it used any API in each group ----
proc_groups_long <- andmal_before %>%
  select(Category, all_of(unique(unlist(api_proc_groups)))) %>%
  mutate(
    ProcessMgmt = as.integer(
      rowSums(across(all_of(api_proc_groups$ProcessMgmt), ~ . > 0), na.rm = TRUE) > 0
    ),
    CommandExec = as.integer(
      rowSums(across(all_of(api_proc_groups$CommandExec), ~ . > 0), na.rm = TRUE) > 0
    ),
    NativeLoad = as.integer(
      rowSums(across(all_of(api_proc_groups$NativeLoad), ~ . > 0), na.rm = TRUE) > 0
    )
  ) %>%
  select(Category, ProcessMgmt, CommandExec, NativeLoad) %>%
  pivot_longer(
    cols      = c(ProcessMgmt, CommandExec, NativeLoad),
    names_to  = "group",
    values_to = "present"
  )

# Proportion of samples in each Category that have ≥1 call in each group ----
proc_group_summary <- proc_groups_long %>%
  group_by(Category, group) %>%
  summarise(
    prop_present = mean(present, na.rm = TRUE),
    n_samples    = n(),
    .groups      = "drop"
  )

# Stacked bar: process manipulation index by category ----
p_proc_groups <- ggplot(
  proc_group_summary,
  aes(x = Category, y = prop_present, fill = group)
) +
  geom_col(position = "stack") +  # use 'position = "dodge"' if you prefer side-by-side
  scale_fill_viridis_d(
    option = "D",
    end    = 0.9,
    name   = "API group",
    labels = c(
      ProcessMgmt = "Process management (start/kill)",
      CommandExec = "Command execution",
      NativeLoad  = "Native code loading"
    )
  ) +
  scale_y_continuous(labels = label_percent(accuracy = 1)) +
  labs(
    title    = "Process manipulation index by malware category (before reboot)",
    subtitle = "Each segment = proportion of samples with ≥1 call in that API group\nNote: segments can overlap, so bars may exceed 100% height",
    x = "Malware category",
    y = "Proportion of samples"
  ) +
  andmal_theme +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

p_proc_groups

# Scatterplot: network bytes vs WebView calls
p_net_webview <- ggplot(
  andmal_before,
  aes(
    x = log_NetTxBytes,
    y = log_WebView_calls,
    colour = fam_color
  )
) +
  geom_point(alpha = 0.6, size = 1.2) +
  facet_wrap(~ Category, scales = "free") +
  scale_colour_identity(
    name   = "Family rank within category",
    breaks = c("red", "blue", "green", "yellow", "grey70"),
    labels = c("Top 1 family", "Top 2 family",
               "Top 3 family", "Top 4 family", "Other families"),
    guide  = "legend"
  ) +
  labs(
    title    = "Network activity vs WebView usage (before reboot)",
    subtitle = "log10(Network_TotalTransmittedBytes + 1) vs log10(total WebView calls), facetted by category\nTop 4 families in each category highlighted in red/blue/green/yellow",
    x = "log10(Network_TotalTransmittedBytes + 1)",
    y = "log10(total WebView API calls + 1)"
  ) +
  andmal_theme

p_net_webview

# Violin: network throughput by Category (TX & RX)

p_net_tx_violin <- ggplot(
  get_combined_data(),
  aes(x = Category, y = log_NetTxBytes, fill = Category)
) +
  geom_violin(trim = FALSE, alpha = 0.8) +
  labs(
    title    = "Network throughput (transmitted bytes) by malware category",
    subtitle = "log10(Network_TotalTransmittedBytes + 1)",
    x = "Malware category",
    y = "log10(Network_TotalTransmittedBytes + 1)"
  ) +
  category_fill +   # from earlier: scale_fill_viridis_d(...)
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_net_tx_violin

# Received bytes ----
p_net_rx_violin <- ggplot(
  get_combined_data(),
  aes(x = Category, y = log_NetRxBytes, fill = Category)
) +
  geom_violin(trim = FALSE, alpha = 0.8) +
  labs(
    title    = "Network throughput (received bytes) by malware category",
    subtitle = "log10(Network_TotalReceivedBytes + 1)",
    x = "Malware category",
    y = "log10(Network_TotalReceivedBytes + 1)"
  ) +
  category_fill +
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_net_rx_violin

# Before vs after reboot: boxplots of network TX by Category

p_net_tx_box_reboot <- ggplot(
  get_combined_data(),
  aes(x = Category, y = log_NetTxBytes, fill = reboot_state)
) +
  geom_boxplot(outlier.alpha = 0.3, position = position_dodge(width = 0.8)) +
  labs(
    title    = "Network transmitted bytes: before vs after reboot",
    subtitle = "log10(Network_TotalTransmittedBytes + 1), side-by-side by reboot state",
    x = "Malware category",
    y = "log10(Network_TotalTransmittedBytes + 1)",
    fill = "Reboot state"
  ) +
  scale_fill_manual(
    values = c("Before reboot" = "#440154FF", "After reboot" = "#21908CFF")
  ) +
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_net_tx_box_reboot

# 1) Category-level means for all File/DB APIs ----
filedb_means <- get_combined_data() %>%
  select(Category, all_of(filedb_apis)) %>%
  group_by(Category) %>%
  summarise(
    across(everything(), ~ mean(.x, na.rm = TRUE)),
    .groups = "drop"
  )

# Turn into matrix: rows = Categories, cols = APIs ----
filedb_mat <- filedb_means %>%
  column_to_rownames("Category") %>%
  as.matrix()

# Replace NaN/Inf (e.g., mean of all-NA column) with 0 ----
filedb_mat[!is.finite(filedb_mat)] <- 0

# 2) Drop APIs with zero variance (no information) ----
col_sds <- apply(filedb_mat, 2, sd, na.rm = TRUE)

keep_cols <- names(col_sds)[col_sds > 0 & !is.na(col_sds)]
filedb_mat2 <- filedb_mat[, keep_cols, drop = FALSE]

# 3) Z-score across categories per API ----
filedb_mat_scaled <- scale(filedb_mat2)  # center & scale each column

# 4) Hierarchical clustering on rows (Categories) and columns (APIs) ----
row_clust <- hclust(dist(filedb_mat_scaled))
col_clust <- hclust(dist(t(filedb_mat_scaled)))

row_order <- rownames(filedb_mat_scaled)[row_clust$order]
col_order <- colnames(filedb_mat_scaled)[col_clust$order]

# 5) Long format for ggplot, using clustered ordering ----
filedb_long <- as.data.frame(filedb_mat_scaled) %>%
  rownames_to_column("Category") %>%
  pivot_longer(
    cols      = -Category,
    names_to  = "api_call",
    values_to = "z_mean_calls"
  ) %>%
  mutate(
    Category = factor(Category, levels = row_order),
    api_call = factor(api_call, levels = col_order)
  )

# 6) Heatmap ----
p_filedb_heatmap <- ggplot(
  filedb_long,
  aes(x = Category, y = api_call, fill = z_mean_calls)
) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(
    option = "B",
    name   = "Z-scored\nmean calls"
  ) +
  labs(
    title    = "File I/O and database activity by malware category",
    subtitle = "Z-scored mean call counts per API; APIs with no variance removed, rows/cols clustered",
    x = "Malware category",
    y = "File / DB API"
  ) +
  andmal_theme +
  theme(
    panel.grid = element_blank()
  )

p_filedb_heatmap

# Heatmap All categories: reads vs writes ---- 
p_db_read_write <- ggplot(
  get_combined_data(),
  aes(x = log_DB_reads, y = log_DB_writes)
) +
  stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", alpha = 0.8) +
  scale_fill_viridis_c(option = "inferno", name = "Density") +
  labs(
    title    = "Database read vs write activity",
    subtitle = "log10(total DB reads + 1) vs log10(total DB writes + 1) per sample",
    x = "log10(total DB read calls + 1)",
    y = "log10(total DB write calls + 1)"
  ) +
  andmal_theme

p_db_read_write

# Heatmap Facet: reads vs writes ---- 
p_db_read_write_fam <- ggplot(
  andmal_before,
  aes(x = log_DB_reads, y = log_DB_writes)
) +
  stat_density_2d(aes(fill = after_stat(level)), geom = "polygon", alpha = 0.8) +
  facet_wrap(~ Category, scales = "free") +
  scale_fill_viridis_c(option = "inferno", name = "Density") +
  labs(
    title    = "Database read vs write activity (before reboot)",
    subtitle = "log10(total DB reads + 1) vs log10(total DB writes + 1), facetted by category",
    x = "log10(total DB read calls + 1)",
    y = "log10(total DB write calls + 1)"
  ) +
  andmal_theme

p_db_read_write_fam

## 2. Keep only those Dex columns that actually exist in your data ----
# (Optional) See which ones were missing:
setdiff(dex_apis, names(andmal_before))
# You can inspect this in the console if you're curious.

## 3. Summarise per Category: proportion of samples with any Dex loading ----
# (Moved to index.qmd)


# Cryptography and Encryption

p_crypto_intensity <- ggplot(
  get_combined_data(),
  aes(x = Category, y = log_crypto, fill = Category)
) +
  geom_violin(trim = FALSE, alpha = 0.8) +
  category_fill +
  labs(
    title    = "Crypto intensity by malware category",
    subtitle = "log10(total crypto-related API calls + 1)\nCrypto APIs: Cipher_doFinal, MessageDigest_*, SecretKeySpec_.init",
    x = "Malware category",
    y = "log10(crypto_calls + 1)"
  ) +
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_crypto_intensity

p_crypto_base64 <- ggplot(
  get_combined_data(),
  aes(
    x = log_base64,
    y = log_crypto,
    colour = Category
  )
) +
  geom_point(alpha = 0.6, size = 1.2) +
  category_col +
  labs(
    title    = "Crypto vs Base64 usage by malware category",
    subtitle = "log10(total Base64 calls + 1) vs log10(total crypto calls + 1)",
    x = "log10(Base64_calls + 1)",
    y = "log10(crypto_calls + 1)"
  ) +
  andmal_theme

p_crypto_base64

#IPC/Binder plots

We’ll group APIs into 4 behaviors:

Broadcasts – sendBroadcast / sendStickyBroadcast

Services – startService / stopService

Receivers – any *_registerReceiver / ActivityThread_handleReceiver

Activities – any *_startActivity

Then compute, for each Category, the proportion of samples that use each behavior at least once.

# Build per-sample flags for each IPC behavior group ----
ipc_group_summary <- get_combined_data() %>%
  select(Category, has_broadcast, has_service, has_receiver, has_activity) %>%
  pivot_longer(
    cols      = c(has_broadcast, has_service, has_receiver, has_activity),
    names_to  = "ipc_group",
    values_to = "present"
  ) %>%
  mutate(
    ipc_group = recode(
      ipc_group,
      has_broadcast = "Broadcasts",
      has_service   = "Services",
      has_receiver  = "Receivers",
      has_activity  = "Activities"
    )
  ) %>%
  group_by(Category, ipc_group) %>%
  summarise(
    prop_present = mean(present, na.rm = TRUE),
    n_samples    = n(),
    .groups      = "drop"
  )

# Bar chart: proportion by Category & IPC group ----
p_ipc_groups <- ggplot(
  ipc_group_summary,
  aes(x = Category, y = prop_present, fill = ipc_group)
) +
  geom_col(position = "dodge") +
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_viridis_d(
    option = "D",
    end    = 0.9,
    name   = "IPC/Binder behavior"
  ) +
  labs(
    title    = "IPC, Binder & broadcast behavior by malware category",
    subtitle = "Proportion of samples that use each IPC group at least once",
    x = "Malware category",
    y = "% of samples"
  ) +
  andmal_theme +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

p_ipc_groups

# Privacy
p_pii_index <- ggplot(
  get_combined_data(),
  aes(x = Category, y = log_PII_access, fill = Category)
) +
  geom_violin(trim = FALSE, alpha = 0.8) +
  category_fill +
  labs(
    title    = "PII access intensity by malware category",
    subtitle = "log10(PII_access_count + 1), where PII = IDs + accounts + location + mic calls",
    x = "Malware category",
    y = "log10(PII_access_count + 1)"
  ) +
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_pii_index

# Long + summary for PII type proportions
pii_long <- get_combined_data() %>%
  select(Category, has_ids, has_accounts, has_location, has_mic) %>%
  pivot_longer(
    cols      = c(has_ids, has_accounts, has_location, has_mic),
    names_to  = "pii_type",
    values_to = "present"
  ) %>%
  mutate(
    pii_type = recode(
      pii_type,
      has_ids      = "Identifiers (device + WiFi)",
      has_accounts = "Accounts & content",
      has_location = "Location",
      has_mic      = "Microphone"
    )
  )

pii_summary <- pii_long %>%
  group_by(Category, pii_type) %>%
  summarise(
    prop_present = mean(present, na.rm = TRUE),
    n_samples    = n(),
    .groups      = "drop"
  )

# Stacked bar per Category: what PII is accessed?
p_pii_type <- ggplot(
  pii_summary,
  aes(x = Category, y = prop_present, fill = pii_type)
) +
  geom_col(position = "stack") +
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_viridis_d(
    option = "D",
    end    = 0.9,
    name   = "PII type"
  ) +
  labs(
    title    = "Types of PII accessed by malware category",
    subtitle = "Each bar shows the proportion of samples accessing different PII types (may overlap)",
    x = "Malware category",
    y = "% of samples"
  ) +
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_pii_type

# Long format for location/mic + reboot_state
loc_mic_long <- get_combined_data() %>%
  mutate(
    has_location = location_calls > 0,
    has_mic      = mic_calls      > 0
  ) %>%
  select(Category, reboot_state, has_location, has_mic) %>%
  pivot_longer(
    cols      = c(has_location, has_mic),
    names_to  = "sensor_type",
    values_to = "present"
  ) %>%
  mutate(
    sensor_type = recode(
      sensor_type,
      has_location = "Location",
      has_mic      = "Microphone"
    )
  )

loc_mic_summary <- loc_mic_long %>%
  group_by(Category, reboot_state, sensor_type) %>%
  summarise(
    prop_present = mean(present, na.rm = TRUE),
    n_samples    = n(),
    .groups      = "drop"
  )

# Bar chart: before vs after reboot for location/mic
p_loc_mic_reboot <- ggplot(
  loc_mic_summary,
  aes(x = Category, y = prop_present, fill = reboot_state)
) +
  geom_col(position = "dodge") +
  facet_wrap(~ sensor_type) +
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_manual(
    values = c("Before reboot" = "#440154FF", "After reboot" = "#21908CFF"),
    name   = "Reboot state"
  ) +
  labs(
    title    = "Location and microphone access: before vs after reboot",
    subtitle = "Proportion of samples touching location/mic APIs, by category & reboot state",
    x = "Malware category",
    y = "% of samples"
  ) +
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_loc_mic_reboot

p_log_process <- ggplot(
  get_combined_data(),
  aes(
    x = log_Process_total,
    y = log_Logcat_total,
    colour = Category
  )
) +
  geom_point(alpha = 0.6, size = 1.2) +
  facet_wrap(~ reboot_state) +
  category_col +
  labs(
    title    = "Logcat volume vs process activity",
    subtitle = "log10(Process_total + 1) vs log10(Logcat_total + 1), facetted by reboot state",
    x = "log10(Process_total + 1)",
    y = "log10(Logcat_total + 1)"
  ) +
  andmal_theme

p_log_process

battery_long <- get_combined_data() %>%
  select(Category, Battery_wakelock, Battery_service) %>%
  pivot_longer(
    cols      = c(Battery_wakelock, Battery_service),
    names_to  = "battery_metric",
    values_to = "value"
  ) %>%
  mutate(
    battery_metric = recode(
      battery_metric,
      Battery_wakelock = "Wakelock count",
      Battery_service  = "Battery service events"
    )
  )

p_battery <- ggplot(
  battery_long,
  aes(x = Category, y = value, fill = Category)
) +
  geom_boxplot(outlier.alpha = 0.3) +
  facet_wrap(~ battery_metric, scales = "free_y") +
  category_fill +
  labs(
    title    = "Battery-related behavior by malware category",
    subtitle = "Battery_wakelock and Battery_service distributions per category",
    x = "Malware category",
    y = "Value"
  ) +
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_battery

log_level_sums <- get_combined_data() %>%
  group_by(Category) %>%
  summarise(
    error   = sum(Logcat_error,   na.rm = TRUE),
    warning = sum(Logcat_warning, na.rm = TRUE),
    info    = sum(Logcat_info,    na.rm = TRUE),
    debug   = sum(Logcat_debug,   na.rm = TRUE),
    verbose = sum(Logcat_verbose, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  pivot_longer(
    cols      = c(error, warning, info, debug, verbose),
    names_to  = "log_level",
    values_to = "count"
  ) %>%
  group_by(Category) %>%
  mutate(
    total = sum(count, na.rm = TRUE),
    frac  = if_else(total > 0, count / total, 0)
  ) %>%
  ungroup() %>%
  mutate(
    log_level = factor(
      log_level,
      levels = c("error", "warning", "info", "debug", "verbose"),
      labels = c("Error", "Warning", "Info", "Debug", "Verbose")
    )
  )

p_log_levels <- ggplot(
  log_level_sums,
  aes(x = Category, y = frac, fill = log_level)
) +
  geom_col(position = "stack") +
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_viridis_d(
    option = "D",
    end    = 0.9,
    name   = "Log level"
  ) +
  labs(
    title    = "Log level composition by malware category",
    subtitle = "Fraction of log messages by level (aggregated across samples)",
    x = "Malware category",
    y = "% of log messages"
  ) +
  andmal_theme +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_log_levels
```
